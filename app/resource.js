// Generated by CoffeeScript 1.6.3
var mongoose, util;

mongoose = require('mongoose');

util = require('util');

exports.register = function(app, schema, options) {
  var plural, single, transformModel, transformQuery, transform_pump, updateModel, withModel;
  plural = (options['root'] || '') + '/api/' + schema.modelName;
  single = plural + '/:id';
  withModel = function(req, res, next) {
    var a, q, _i, _len, _ref;
    q = schema.findById(req.params.id);
    _ref = options.populate || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      a = _ref[_i];
      q.populate(a);
    }
    return q.exec(function(err, item) {
      if (err) {
        return res.send(500, err);
      }
      if (!item) {
        return res.send(404);
      }
      req.model = item;
      return next();
    });
  };
  updateModel = function(model, values, next) {
    var n, part, path, type, _i, _len, _ref, _ref1;
    _ref = model.schema.paths;
    for (path in _ref) {
      type = _ref[path];
      if (!(path !== '_id' && path !== 'id')) {
        continue;
      }
      n = values;
      _ref1 = path.split('.');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        part = _ref1[_i];
        n = n != null ? n[part] : void 0;
      }
      if (n !== void 0) {
        model.set(path, n);
      }
    }
    if (options.update) {
      return options.update(model, values, next);
    } else {
      return next(null, model);
    }
  };
  transformModel = function(model, next) {
    if (model.toObject) {
      model = model.toObject();
    }
    delete model['password'];
    delete model['salt'];
    if (options.transform) {
      return options.transform(model, next);
    } else {
      return next(null, model);
    }
  };
  transformQuery = function(req, query, spec) {
    spec.s = req.query.s || req.body.s;
    spec.i = Number(req.query.i || req.body.i || 0);
    spec.n = Number(req.query.n || req.body.n || 1000);
    if (spec.s) {
      query.sort(spec.s);
    }
    query.limit(spec.n !== NaN ? Math.min(spec.n, 1000) : 1000);
    if (spec.i !== NaN) {
      query.skip(spec.i);
    }
    query.lean(true);
    if (options.query) {
      query = options.query(req, query, spec);
    }
    return query;
  };
  app.get(single, withModel, function(req, res) {
    return transformModel(req.model, function(model) {
      return res.send(model);
    });
  });
  app.put(single, withModel, function(req, res) {
    return updateModel(req.model, req.body, function(err, model) {
      if (err) {
        return res.send(500, err);
      }
      return model.save(function(err) {
        if (err) {
          return res.send(500, err);
        }
        return transformModel(req.model, function(err, model) {
          if (err) {
            return res.send(500, err);
          }
          return res.send(model);
        });
      });
    });
  });
  app.del(single, withModel, function(req, res) {
    return req.model.remove(function(err) {
      if (err) {
        return res.send(500, err);
      }
      return res.send({});
    });
  });
  transform_pump = function(source, destination, next) {
    if (source.length === destination.length) {
      return next(null, destination);
    }
    return transformModel(source[destination.length], function(err, model) {
      if (err) {
        return next(err);
      }
      destination.push(model);
      return process.nextTick(function() {
        return transform_pump(source, destination, next);
      });
    });
  };
  app.get(plural, function(req, res) {
    var q, spec;
    spec = {};
    q = schema.find();
    if (options.query) {
      q = options.query(req, q, spec);
    }
    return q.count(function(err, count) {
      if (err) {
        return res.send(500, err);
      }
      spec.count = count;
      q = transformQuery(req, schema.find(), spec);
      return q.exec(function(err, list) {
        if (err) {
          return res.send(500, err);
        }
        return transform_pump(list, [], function(err, transformed) {
          if (err) {
            return res.send(500, err);
          }
          spec.items = transformed;
          return res.send(200, spec);
        });
      });
    });
  });
  return app.post(plural, function(req, res) {
    req.model = new schema();
    return updateModel(req.model, req.body, function(err, model) {
      if (err) {
        return res.send(500, err);
      }
      return model.save(function(err) {
        if (err) {
          return res.send(500, err);
        }
        return transformModel(req.model, function(err, model) {
          if (err) {
            return res.send(500, err);
          }
          return res.send(model);
        });
      });
    });
  });
};
